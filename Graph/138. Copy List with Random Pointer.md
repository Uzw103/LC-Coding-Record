\#

\# @lc app=leetcode id=138 lang=python3

\#

\# [138] ***Copy List with Random Pointer***

\#***Construct a [deep copy](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list. The list contains `random` and `next` pointer modules. For example, if there are two nodes `X` and `Y` in the original list, where `X.random --> Y`, then for the corresponding two nodes `x` and `y` in the copied list, `x.random --> y`.***

***Return the head of the copied linked list.*** 

***Example:***

```
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
```

### ==Solution:==

1. O1空间复杂度：在每个original结点后添加copy结点，并链接在original node后面，**无需创建新dic存储**。
2. 改变original node和copy node的random和next指针即可

\# @lc code=start

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return head
        ori_head = head
        # 创建新copy链表
        while ori_head:
            copy_head = Node(ori_head.val, None,None)
            copy_head.next = ori_head.next
            ori_head.next = copy_head
            ori_head = copy_head.next
        
        # 链接random指针
        ori_head = head
        while ori_head:
            ori_head.next.random = ori_head.random.next if ori_head.random else None
            ori_head = ori_head.next.next
        
        # 分离copy list和original list
        ori_head = head
        copy_head = head.next
        res_head = head.next  # 相当于锁定了copy后的链表头 因为接下来的遍历会还原original链表 而且copy后的链表头找不到了就 因为遍历结束后只停留在最后的结点上 
        while ori_head:
            # ori_head.next = ori_head.next.next
            # copy_head.next = copy_head.next.next if copy_head.next else None
            ori_head.next = copy_head.next
            copy_head.next = ori_head.next.next if ori_head.next else None
            ori_head = ori_head.next
            copy_head = copy_head.next
        return res_head
```

